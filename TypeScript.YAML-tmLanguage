# [PackageDev] target_format: plist, ext: tmLanguage
---
name: TypeScript
scopeName: source.ts
fileTypes: [ts]
uuid: ef98eb90-bf9b-11e4-bb52-0800200c9a66

patterns:
- include: '#statements'

repository:
  statements:
    patterns:
    - include: '#for-in-simple'
    - include: '#string'
    - include: '#regex'
    - include: '#template'
    - include: '#comment'
    - include: '#literal'
    - include: '#declaration'
    - include: '#switch-statement'
    - include: '#decl-block'
    - include: '#control-statement'
    # add label
    - include: '#expression'

  var-expr:
    name: meta.var.expr.ts
    begin: (?:(\bexport)\s+)?(?<!\()\s*\b(var|let|const(?!\s+enum\b))\b
    beginCaptures:
      '1': { name: keyword.control.export.ts }
      '2': { name: storage.type.ts }
    end: (?=$|;)
    patterns:
    - include: '#var-single-variable'
    - include: '#comment'

  var-single-variable:
    name: meta.var-single-variable.expr.ts
    begin: \b([a-zA-Z_$][\w$]*)\b
    beginCaptures:
      '1': { name: variable.other.readwrite.ts }
    end: (?=$|[;,])
    patterns:
    - include: '#variable-initializer'
    - begin: \G
      end: (?!\G)(?=$|[;,=])
      patterns:
      - include: '#type-annotation'
      - include: '#string'
      - include: '#comment'

  ternary-expression:
    begin: (?=\?)
    end: (?=$|[;,}])
    patterns:
    - include: '#ternary-operator'
    - include: '#expression' 

  ternary-operator:
    begin: (\?)
    beginCaptures:
      '0': { name: keyword.operator.ternary.ts }
    end: (:)
    endCaptures:
      '0': { name: keyword.operator.ternary.ts }      
    patterns:
    - include: '#expression' 

  expression:
    name: meta.expression.ts
    patterns:
    - include: '#string'
    - include: '#regex'
    - include: '#template'
    - include: '#comment'
    - include: '#literal'
    - include: '#function-declaration'
    - include: '#paren-expression'
    - include: '#ternary-expression'
    - include: '#cast'
    - include: '#new-expr'
    - include: '#arrow-body'
    - include: '#object-literal'
    - include: '#expression-operator'
    - include: '#imply-operator'
    - include: '#operators'
    - include: '#function-call'

  control-statement:
    # TODO: convert this to actual statements instead
    patterns:
    - name: keyword.control.trycatch.ts
      match: (?<!\.)\b(catch|finally|throw|try)\b
    - name: keyword.control.loop.ts
      match: (?<!\.)\b(break|continue|do|for|goto|while)\b
    - name: keyword.control.flow.ts
      match: (?<!\.)\b(await|return|yield)\b
    - name: keyword.control.switch.ts
      match: (?<!\.)\b(case|default|switch)\b
    - name: keyword.control.conditional.ts
      match: (?<!\.)\b(else|if)\b
    - name: keyword.control.with.ts
      match: (?<!\.)\b(with)\b
    - name: keyword.other.ts
      match: (?<!\.)\b(debugger)\b
    - name: storage.modifier.ts
      match: (?<!\.)\b(declare)\b

  declaration:
    name: meta.declaration.ts
    patterns:
     - include: '#var-expr'
     - include: '#function-declaration'
     - include: '#class-or-interface-declaration'
     - include: '#type-declaration'
     - include: '#enum-declaration'
     # Todo: to change this to import declaration
     - include: '#import-operator'
     # TODO: change this to actual declarations of export, import, namespace
     - include: '#storage-keyword'

  type-declaration:
    name: meta.type.declaration.ts
    begin: (?:(\bexport)\s+)?\b(type)\b\s+([a-zA-Z_$][\w$]*)\s*
    beginCaptures:
      '1': { name: keyword.control.export.ts }
      '2': { name: storage.type.type.ts }
      '3': { name: entity.name.type.ts }
    end: (?=$|[,);>]|var|type|function|class|interface|namespace|enum|declare|export)
    patterns:
      - include: '#comment'
      - include: '#type-parameters'
      - include: '#type'
      - name: keyword.operator.assignment.ts
        match: '=\s*'

  enum-declaration:
    name: meta.enum.declaration.ts
    match: (?:(\bexport)\s+)?(?:\b(const)\s+)?\b(enum)\s+([a-zA-Z_$][\w$]*)
    captures:
      '1': { name: keyword.control.export.ts }
      '2': { name: storage.modifier.ts}
      '3': { name: storage.type.enum.ts }
      '4': { name: entity.name.type.enum.ts }

  class-or-interface-declaration:
    name: meta.declaration.object.ts
    begin: '\b(?:(export)\s+)?\b(?:(abstract)\s+)?\b(?<!\.)(?:(class)|(interface))\b'
    beginCaptures:
      '1': { name: keyword.control.export.ts }
      '2': { name: storage.modifier.ts }
      '3': { name: storage.type.class.ts }
      '4': { name: storage.type.interface.ts }
    end: (?<=\})
    endCaptures:
      '1': { name: punctuation.definition.block.ts }
    patterns:
    - include: '#comment'
    - include: '#class-or-interface-heritage' # Must be before object-name to consume the "extends" keyword.
    - include: '#class-or-interface-name'
    - include: '#type-parameters' # Must be applied after object-name e.g. interface KeyValuePair<K, V>
    - include: '#class-or-interface-body'

  class-or-interface-name:
    name: meta.object.name.ts
    match: '[a-zA-Z_$][\w$]*'
    captures:
      '0': { name: 'entity.name.class.ts' }

  class-or-interface-heritage:
    name: meta.object.heritage.ts
    begin: '(?:\b(extends|implements)\b)'
    beginCaptures:
      '1': { name: storage.modifier.ts }
    end: (?=\{)
    endCaptures:
      '1': { name: punctuation.definition.block.ts }
    patterns:
    - include: '#comment'
    - include: '#class-or-interface-heritage'
    - include: '#type-parameters'
    - include: '#class-or-interface-heritage-type'

  class-or-interface-heritage-type:
    name: meta.object.heritage.parent.ts
    match: '(?:\b([a-zA-Z_$][\w$]*)\b)'
    captures:
      '1': { name: entity.other.inherited-class.ts }

  class-or-interface-body:
    name: meta.object.body.ts
    begin: \{
    beginCaptures:
      '0': { name: punctuation.definition.block.ts }
    end: \}
    endCaptures:
      '0': { name: punctuation.definition.block.ts }
    patterns:
    - include: "#string"
    - include: '#comment'
    - include: '#field-declaration'
    - include: '#method-declaration'
    - include: '#indexer-declaration'
    - include: '#type-annotation'
    - include: '#variable-initializer'
    - include: '#access-modifier'
    - include: '#static-modifier'
    - include: '#property-accessor'

  type-object:
    name: meta.object.type.ts
    begin: \{
    beginCaptures:
      '0': { name: punctuation.definition.block.ts }
    end: \}
    endCaptures:
      '0': { name: punctuation.definition.block.ts }
    patterns:
    - include: '#type-object-members'

  type-object-members:
    patterns:
    - include: '#comment'
    - include: '#field-declaration'
    - include: '#method-declaration'
    - include: '#indexer-declaration'
    - include: '#type-annotation'

  field-declaration:
    name: meta.field.declaration.ts
    begin: (?<!\()\s*((?:\b[a-zA-Z_$][\w$]*)|(?:\'[^']*\')|(?:\"[^"]*\"))\s*(\?\s*)?(?=(=|:))
    beginCaptures:
      '1': { name: variable.object.property.ts }
      '2': { name: keyword.operator.optional.ts }
    end: '(?=\}|;|,|$)|(?<=\})'
    patterns:
    - include: '#ternary-expression'
    - include: '#type-annotation'
    - include: '#expression'

  method-declaration:
    name: meta.method.declaration.ts
    begin: '\b(?:(abstract)\s+)?\b(?:(public|private|protected)\s+)?\b(?:(async)\s+)?(?:(get|set)\s+)?(?:(new)|(?:\b(constructor)\b)|(?:([a-zA-Z_$][\.\w$]*)\s*(\??)))?\s*(?=\(|\<)'
    beginCaptures:
      '1': { name: storage.modifier.ts } # captures keyword (abstract)
      '2': { name: storage.modifier.ts } # captures keyword (public or private or protected)
      '3': { name: storage.modifier.async.ts } # captures keyword (async)
      '4': { name: storage.type.property.ts } # captures keyword (get|set)
      '5': { name: keyword.operator.new.ts } # captures keyword (new)
      '6': { name: storage.type.ts } # captures keyword (constructor)
      '7': { name: entity.name.function.ts } # captures method name ([a-zA-Z_$][\.\w$]*)
      '8': { name: keyword.operator.optional.ts } # captures (\??)
    end: '(?=\}|;|,)|(?<=\})'
    patterns:
    - include: '#comment'
    - include: '#type-parameters'
    - include: '#function-type-parameters'
    - include: '#return-type'
    - include: '#method-overload-declaration'
    - include: '#decl-block'

  method-overload-declaration:
    name: meta.method.overload.declaration.ts
    match: '\b(?:(abstract)\s+)?\b(?:(public|private|protected)\s+)?\b(?:(async)\s+)?(?:(get|set)\s+)?(?:(new)|(?:\b(constructor)\b)|(?:([a-zA-Z_$][\.\w$]*)\s*(\??)))?\s*(?=\(|\<)'
    captures:
      '1': { name: storage.modifier.ts } # captures keyword (abstract)
      '2': { name: storage.modifier.ts } # captures keyword (public or private or protected)
      '3': { name: storage.modifier.ts } # captures keyword (async)
      '4': { name: storage.type.property.ts } # captures keyword (get|set)
      '5': { name: keyword.operator.ts } # captures keyword (new)
      '6': { name: entity.name.function.constructor.ts } # captures keyword (constructor)
      '7': { name: entity.name.function.ts } # captures method name ([a-zA-Z_$][\.\w$]*)
      '8': { name: keyword.operator.optional.ts } # captures (\??)

  indexer-declaration:
    name: meta.indexer.declaration.ts
    begin: \[
    beginCaptures:
      '0': { name: meta.brace.square.ts }
    end: (\])\s*(\?\s*)?|$
    endCaptures:
      '1': { name: meta.brace.square.ts }
      '2': { name: keyword.operator.optional.ts }
    patterns:
    - include: '#type-annotation'
    - include: '#indexer-parameter'

  indexer-parameter:
    name: meta.indexer.parameter.ts
    match: ([a-zA-Z_$][\w$]*)(?=\:)
    captures:
      '1': { name: variable.parameter.ts}

  function-declaration:
    name: meta.function.ts
    begin: \b(?:(export)\s+)?(?:(async)\s+)?(function\b)(?:\s+([a-zA-Z_$][\w$]*))?\s*
    beginCaptures:
      '1': { name: keyword.control.export.ts }
      '2': { name: storage.modifier.async.ts }
      '3': { name: storage.type.function.ts }
      '4': { name: entity.name.function.ts }
    end: (?=;|\})|(?<=\})
    patterns:
    - include: '#comment'
    - include: '#type-parameters'
    - include: '#function-type-parameters'
    - include: '#return-type'
    - include: '#function-overload-declaration'
    - include: '#decl-block'

  function-overload-declaration:
    name: meta.function.overload.ts
    match: \b(?:(export)\s+)?(function\b)(?:\s+([a-zA-Z_$][\w$]*))?\s*
    captures:
      '1': { name: keyword.control.export.ts }
      '2': { name: storage.type.function.ts }
      '3': { name: entity.name.function.ts }

  object-literal:
    name: meta.block.ts
    begin: \{
    beginCaptures:
      '0': { name: punctuation.definition.block.ts }
    end: \}
    endCaptures:
      '0': { name: punctuation.definition.block.ts }
    patterns:
    - include: '#object-member'

  decl-block:
    name: meta.decl.block.ts
    begin: \{
    beginCaptures:
      '0': { name: punctuation.definition.block.ts }
    end: \}
    endCaptures:
      '0': { name: punctuation.definition.block.ts }
    patterns:
    - include: '#statements'

  arrow-body:
    name: meta.decl.block.ts
    begin: (?<==>)\s*(\{)
    beginCaptures:
      '1': { name: punctuation.definition.block.ts }
    end: \}
    endCaptures:
      '0': { name: punctuation.definition.block.ts }
    patterns:
    - include: '#statements'

  parameter-name:
    match: '(?:\s*\b(public|private|protected)\b\s+)?(\.\.\.)?\s*([a-zA-Z_$][\w$]*)\s*(\??)'
    captures:
      '1': { name: storage.modifier.ts }
      '2': { name: keyword.operator.spread.ts }
      '3': { name: variable.parameter.ts }
      '4': { name: keyword.operator.optional.ts }

  return-type:
    name: meta.return.type.ts
    begin: '(?<=\))\s*:'
    end: (?<!:)((?=$)|(?=\{|;|//))
    patterns:
    # Handle returning of object type specifically here so as to not confuse it with the start of function block
    - name: meta.object.type.ts
      begin: (?<=:)\s*(\{)
      beginCaptures:
        '1': { name: punctuation.definition.block.ts }
      end: \}
      endCaptures:
        '0': { name: punctuation.definition.block.ts }
      patterns:
      - include: '#type-object-members'
    - include: '#type'

  type-annotation:
    name: meta.type.annotation.ts
    begin: ":"
    end: (?=$|[,);\}\]]|//)|(?==[^>])|(?<=[\}>\]\)]|[a-zA-Z_$])\s*(?=\{)
    patterns:
    - include: '#expression-operator'
    - include: '#type'
    - include: '#string'
    - include: '#comment'

  type:
    name: meta.type.ts
    patterns:
    - include: '#type-primitive'
    - include: '#type-parameters'
    - include: '#type-tuple'
    - include: '#type-object'
    - include: '#type-operator'
    - include: '#type-paren-or-function-type-parameters'
    - include: '#type-function-return-type'
    - include: '#type-name'

  function-type-parameters:
    name: meta.function.type.parameter.ts
    begin: \(
    beginCaptures:
      '0': { name: punctuation.definition.parameters.begin.ts }
    end: \)
    endCaptures:
      '0': { name: punctuation.definition.parameters.end.ts }
    patterns:
    - include: '#comment'
    - include: '#parameter-name'
    - include: '#type-annotation'
    - include: '#variable-initializer'

  type-primitive:
    name: support.type.primitive.ts
    match: '\b(string|number|boolean|symbol|any|void|never)\b'

  # Parenthesis can contain either types and function parameters
  # (number | string) or (param: number, param2: string)
  # and it can be nested, for example
  # (number | (param: number, param2: string) => void)
  type-paren-or-function-type-parameters:
    name: meta.type.paren.cover.ts
    begin: '(?:\b(new)\b)?\s*(\()'
    beginCaptures:
      '1': { name: keyword.control.new.ts }
      '2': { name: meta.brace.round.ts }
    end: '\)'
    endCaptures:
      '0': { name: meta.brace.round.ts }
    patterns:
    - include: '#comment'
    - include: '#type'
    - include: '#function-type-parameters'

  type-operator:
    name: keyword.operator.type.ts
    match: '[.|]'

  type-function-return-type:
    name: meta.type.function.return.ts
    begin: '=>'
    beginCaptures:
      '0': { name: storage.type.function.arrow.ts }
    end: (?<!=>)(?=[,\]\)\{\}=;>]|//|$)
    patterns:
    # Handle returning of object type specifically here so as to not confuse it with the start of function block
    - name: meta.object.type.ts
      begin: (?<==>)\s*(\{)
      beginCaptures:
        '1': { name: punctuation.definition.block.ts }
      end: \}
      endCaptures:
        '0': { name: punctuation.definition.block.ts }
      patterns:
      - include: '#type-object-members'
    - include: '#type'

  type-tuple:
    name: meta.type.tuple.ts
    begin: \[
    beginCaptures:
      '0': { name: meta.brace.square.ts }
    end: \]
    endCaptures:
      '0': { name: meta.brace.square.ts }
    patterns:
    - include: '#type'
    - include: '#comment'

  type-name:
    name: entity.name.type.ts
    match: '[a-zA-Z_$][.\w$]*'

  type-parameters:
    name: meta.type.parameters.ts
    begin: '([a-zA-Z_$][\w$]*)?(<)'
    beginCaptures:
      '1': { name: entity.name.type.ts }
      '2': { name: punctuation.definition.typeparameters.begin.ts }
    end: '(?=$)|(>)'
    endCaptures:
      '2': { name: punctuation.definition.typeparameters.end.ts }
    patterns:
    - name: storage.modifier.ts
      match: '\b(extends)\b'
    - include: '#comment'
    - include: '#type'

  variable-initializer:
    begin: (?<!=|!)(=)(?!=)
    beginCaptures:
      '1': { name: keyword.operator.assignment.ts }
    end: (?=$|[,);])
    patterns:
      - include: '#expression'

  switch-expression:
    name: switch-expression.expr.ts
    begin: \b(switch)\b\s*\(
    beginCaptures:
      '1': { name: keyword.control.switch.ts }
    end: \)
    patterns:
    - include: '#expression'

  switch-block:
    name: switch-block.expr.ts
    begin: '{'
    beginCaptures:
      '0': { name: punctuation.definition.block.ts }
    end: (?=\})
    patterns:
    - include: '#case-clause'
    - include: '#statements'

  case-clause:
    name: case-clause.expr.ts
    begin: '(?<!\.)\b(case|default(?=:))\b'
    beginCaptures:
      '1': { name: keyword.control.switch.ts }
    end: ':'
    patterns:
    - include: '#expression'

  switch-statement:
    name: switch-statement.expr.ts
    begin: (?=\bswitch\b\s*\()
    end: '}'
    endCaptures:
      '0': {name: punctuation.definition.block.ts}      
    patterns:
    - include: '#switch-expression'
    - include: '#switch-block'

  for-in-simple:
    name: forin.expr.ts
    match: (?<=\()\s*\b(var|let|const)\s+([a-zA-Z_$][\w$]*)\s+(?:(in)|(of))\b
    captures:
      '1': { name: storage.type.ts }
      '2': { name: variable.other.readwrite.ts }
      '3': { name: keyword.operator.in.ts }
      '4': { name: keyword.operator.of.ts }

  function-call:
    name: functioncall.expr.ts
    patterns:
    - include: '#type-parameters'
    - include: '#paren-expression'

  cast:
    name: cast.expr.ts
    # We need to differentiate between the relational '<' operator and the beginning of a type assertion/cast using the surrounding context.
    # If '<' is preceeded by 'return', 'throw', 'yield', or 'await', it's most likely a type assertion
    # If '=', '(', ',', ':', or '>' are followed by a '<', it is also likely a type assertion as otherwise it would be a syntax error
    # '<=' and '<<=' are cannot be type assertions, as they are assignment operators.
    begin: '(?:(?<=return|throw|yield|await|[=(,:>]))\s*(<)(?!<?\=)'
    beginCaptures:
      '1': { name: meta.brace.angle.ts }
    end: '>'
    endCaptures:
      '0': { name: meta.brace.angle.ts }
    patterns:
    - include: '#type'

  new-expr:
    name: new.expr.ts
    begin: '\b(new)\b'
    beginCaptures:
      '1': { name: keyword.operator.new.ts }
    # new-expr ends just before any type or call arguments. Type arguments will be picked up by #cast.
    end: '(?=[(;]|$)'
    patterns:
    - include: '#type'
    - include: '#comment'

  object-member:
    name: meta.object.member.ts
    begin: '[a-zA-Z_$][\w$]*\s*:'
    end: (?=,|\})
    patterns:
    - include: '#expression'

  expression-operator:
    patterns:
    - name: keyword.operator.delete.ts
      match: \bdelete\b
    - name: keyword.operator.in.ts
      match: \bin\b
    - name: keyword.operator.of.ts
      match: \bof\b
    - name: keyword.operator.instanceof.ts
      match: \binstanceof\b
    - name: keyword.operator.new.ts
      match: \bnew\b
    - name: keyword.operator.typeof.ts
      match: \btypeof\b
    - name: keyword.operator.void.ts
      match: \bvoid\b
    - name: keyword.control.as.ts
      match: \bas\b
    - name: keyword.operator.is.ts
      match: \bis\b

  imply-operator:
    name: storage.type.function.arrow.ts
    match: =>

  import-operator:
    patterns:
    - name: keyword.control.import.ts
      match: \bimport\b
    - name: keyword.control.from.ts
      match: \bfrom\b

  operators:
    patterns:
    - name: keyword.operator.assignment.compound.ts
      match: \*=|(?<!\()/=|%=|\+=|\-=
    - name: keyword.operator.assignment.compound.bitwise.ts
      match: \&=|\^=|<<=|>>=|>>>=|\|=
    - name: keyword.operator.comparison.ts
      match: ===|!==|==|!=
    - name: keyword.operator.relational.ts
      match: <=|>=|<>|<|>
    - name: keyword.operator.logical.ts
      match: \!|&&|\|\|
    - name: keyword.operator.bitwise.ts
      match: \&|~|\^|\|
    - name: keyword.operator.assignment.ts
      match: \=
    - name: keyword.operator.decrement.ts
      match: --
    - name: keyword.operator.increment.ts
      match: \+\+
    - name: keyword.operator.arithmetic.ts
      match: '%|\*|/|-|\+'

  storage-keyword:
    name: storage.type.ts
    match: \b(var|let|function|const|module|namespace)\b

  paren-expression:
    begin: \(
    beginCaptures:
      '0': {name: meta.brace.round.ts }
    end: \)
    endCaptures:
      '0': {name: meta.brace.round.ts }
    patterns:
    - include: '#expression'

  qstring-double:
    name: string.quoted.double.ts
    begin: '"'
    beginCaptures:
      '0': { name: punctuation.definition.string.begin.ts }
    end: '(")|((?:[^\\\n])$)'
    endCaptures:
      '1': { name: punctuation.definition.string.end.ts }
      '2': { name: invalid.illegal.newline.ts }
    patterns:
    - include: '#string-character-escape'

  qstring-single:
    name: string.quoted.single.ts
    begin: "'"
    beginCaptures:
      '0': { name: punctuation.definition.string.begin.ts }
    end: (\')|((?:[^\\\n])$)
    endCaptures:
      '1': { name: punctuation.definition.string.end.ts }
      '2': { name: invalid.illegal.newline.ts }
    patterns:
    - include: '#string-character-escape'

  regex:
    name: string.regex.ts
    begin: (?<=[=(:,\[?+!]|^|return|=>|&&|\|\|)\s*(/)(?![/*+{}?])(?=.*/)
    beginCaptures:
      '1': {name: punctuation.definition.string.begin.ts}
    end: (/)([gimuy]*)
    endCaptures:
      '1': {name: punctuation.definition.string.end.ts}
      '2': {name: keyword.other.ts}
    patterns:
    - include: '#regexp'

  # regexp syntax is taken from https://github.com/atom/language-javascript/
  regexp:
    patterns:
    - name: keyword.control.anchor.regexp
      match: \\[bB]|\^|\$
    - name: keyword.other.back-reference.regexp
      match: \\[1-9]\d*
    - name: keyword.operator.quantifier.regexp
      match: '[?+*]|\{(\d+,\d+|\d+,|,\d+|\d+)\}\??'
    - name: keyword.operator.or.regexp
      match: \|
    - name: meta.group.assertion.regexp
      begin: (\()((\?=)|(\?!))
      beginCaptures:
        '1': {name: punctuation.definition.group.regexp}
        '2': {name: punctuation.definition.group.assertion.regexp}
        '3': {name: meta.assertion.look-ahead.regexp}
        '4': {name: meta.assertion.negative-look-ahead.regexp}
      end: (\))
      endCaptures:
        '1': {name: punctuation.definition.group.regexp}
      patterns:
      - include: '#regexp'
    - name: meta.group.regexp
      begin: \((\?:)?
      beginCaptures:
        '0': {name: punctuation.definition.group.regexp}
        '1': {name: punctuation.definition.group.capture.regexp}
      end: \)
      endCaptures:
        '0': {name: punctuation.definition.group.regexp}
      patterns:
      - include: '#regexp'
    - name: constant.other.character-class.set.regexp
      begin: (\[)(\^)?
      beginCaptures:
        '1': {name: punctuation.definition.character-class.regexp}
        '2': {name: keyword.operator.negation.regexp}
      end: (\])
      endCaptures:
        '1': {name: punctuation.definition.character-class.regexp}
      patterns:
      - name: constant.other.character-class.range.regexp
        match: (?:.|(\\(?:[0-7]{3}|x\h\h|u\h\h\h\h))|(\\c[A-Z])|(\\.))\-(?:[^\]\\]|(\\(?:[0-7]{3}|x\h\h|u\h\h\h\h))|(\\c[A-Z])|(\\.))
        captures:
          '1': {name: constant.character.numeric.regexp}
          '2': {name: constant.character.control.regexp}
          '3': {name: constant.character.escape.backslash.regexp}
          '4': {name: constant.character.numeric.regexp}
          '5': {name: constant.character.control.regexp}
          '6': {name: constant.character.escape.backslash.regexp}
      - include: '#regex-character-class'
    - include: '#regex-character-class'

  regex-character-class:
    patterns:
    - name: constant.other.character-class.regexp
      match: \\[wWsSdD]|\.
    - name: constant.character.numeric.regexp
      match: \\([0-7]{3}|x\h\h|u\h\h\h\h)
    - name: constant.character.control.regexp
      match: \\c[A-Z]
    - name: constant.character.escape.backslash.regexp
      match: \\.

  string:
    name: string.ts
    patterns:
    - include: '#qstring-single'
    - include: '#qstring-double'

  template:
    name: string.template.ts
    begin: '(?:\b([a-zA-Z_$][a-zA-Z_$0-9]*)\b)?(`)'
    beginCaptures:
      '1': { name: entity.name.function.tagged-template.ts }
      '2': { name: punctuation.definition.string.template.begin.ts }
    end: '`'
    endCaptures:
      '0': { name: punctuation.definition.string.template.end.ts}
    patterns:
     - include: '#template-substitution-element'
     - include: '#string-character-escape'

  string-character-escape:
    name: constant.character.escape.ts
    match: \\(x\h{2}|[0-2][0-7]{0,2}|3[0-6][0-7]?|37[0-7]?|[4-7][0-7]?|.|$)

  template-substitution-element:
    name: meta.template.expression.ts
    begin: \$\{
    beginCaptures:
      '0': { name: punctuation.definition.template-expression.begin.ts }
    end: \}
    endCaptures:
      '0': { name: punctuation.definition.template-expression.end.ts }
    patterns:
      - include: '#expression'

  comment:
    patterns:
    - name: comment.block.documentation.ts
      begin: /\*\*(?!/)
      end: \*/
      captures:
        '0': {name: punctuation.definition.comment.ts}
      patterns:
      - include: '#docblock'
    - name: comment.block.ts
      begin: /\*
      end: \*/
      captures:
        '0': {name: punctuation.definition.comment.ts}
    - begin: (^[ \t]+)?(?=//)
      beginCaptures:
        '1': {name: punctuation.whitespace.comment.leading.ts}
      end: (?!\G)
      patterns:
      - name: comment.line.double-slash.ts
        begin: //
        beginCaptures:
          '0': {name: punctuation.definition.comment.ts}
        end: \n

  docblock:
    patterns:
    - name: storage.type.class.jsdoc
      match: (?<!\w)@(abstract|access|alias|arg|argument|async|attribute|augments|author|beta|borrows|bubbes|callback|chainable|class|classdesc|code|config|const|constant|constructor|constructs|copyright|default|defaultvalue|define|deprecated|desc|description|dict|emits|enum|event|example|exports?|extends|extension|extension_for|extensionfor|external|file|fileoverview|final|fires|for|function|global|host|ignore|implements|inherit[Dd]oc|inner|instance|interface|kind|lends|license|listens|main|member|memberof|method|mixex|mixins?|module|name|namespace|nocollapse|nosideeffects|override|overview|package|param|preserve|private|prop|property|protected|public|read[Oo]nly|record|require[ds]|returns?|see|since|static|struct|submodule|summary|template|this|throws|todo|tutorial|type|typedef|unrestricted|uses|var|variation|version|virtual|writeOnce)\b
    - match: ({\b(?:[a-zA-Z_$][a-zA-Z_$0-9]*)\b})\s\b([a-zA-Z_$][a-zA-Z_$0-9]*)\b\s*((?:(?!\*\/).)*)
      captures:
        '0': {name: other.meta.jsdoc}
        '1': {name: entity.name.type.instance.jsdoc}
        '2': {name: variable.other.jsdoc}
        '3': {name: other.description.jsdoc}

  literal:
    name: literal.ts
    patterns:
    - include: '#numeric-literal'
    - include: '#boolean-literal'
    - include: '#null-literal'
    - include: '#undefined-literal'
    - include: '#numericConstant-literal'
    - include: '#array-literal'
    - include: '#this-literal'
    - include: '#super-literal'

  array-literal:
    name: meta.array.literal.ts
    begin: \[
    beginCaptures:
      '0': { name: meta.brace.square.ts }
    end: \]
    endCaptures:
      '0': { name: meta.brace.square.ts }
    patterns:
    - include: '#expression'

  numeric-literal:
    patterns:
    - name: constant.numeric.hex.ts
      match: \b(?<!\$)0(x|X)[0-9a-fA-F]+\b(?!\$)
    - name: constant.numeric.binary.ts
      match: \b(?<!\$)0(b|B)[01]+\b(?!\$)
    - name: constant.numeric.octal.ts
      match: \b(?<!\$)0(o|O)?[0-7]+\b(?!\$)
    - match: |-
        (?x)
        (?<!\$)(?:
          (?:\b[0-9]+(\.)[0-9]+[eE][+-]?[0-9]+\b)| # 1.1E+3
          (?:\b[0-9]+(\.)[eE][+-]?[0-9]+\b)|       # 1.E+3
          (?:\B(\.)[0-9]+[eE][+-]?[0-9]+\b)|       # .1E+3
          (?:\b[0-9]+[eE][+-]?[0-9]+\b)|            # 1E+3
          (?:\b[0-9]+(\.)[0-9]+\b)|                # 1.1
          (?:\b[0-9]+(\.)\B)|                      # 1.
          (?:\B(\.)[0-9]+\b)|                      # .1
          (?:\b[0-9]+\b(?!\.))                     # 1
        )(?!\$)
      captures:
        '0': {name: constant.numeric.decimal.ts}
        '1': {name: meta.delimiter.decimal.period.ts}
        '2': {name: meta.delimiter.decimal.period.ts}
        '3': {name: meta.delimiter.decimal.period.ts}
        '4': {name: meta.delimiter.decimal.period.ts}
        '5': {name: meta.delimiter.decimal.period.ts}
        '6': {name: meta.delimiter.decimal.period.ts}

  boolean-literal:
    patterns:
     - name: constant.language.boolean.true.ts
       match: \btrue\b
     - name: constant.language.boolean.false.ts
       match: \bfalse\b

  null-literal:
    name: constant.language.null.ts
    match: \bnull\b

  this-literal:
    name: variable.language.this.ts
    match: \bthis\b

  super-literal:
    name: variable.language.super.ts
    match: \bsuper\b  

  undefined-literal:
    name: constant.language.undefined.ts
    match: \bundefined\b

  numericConstant-literal:
    patterns:
    - name: constant.language.nan.ts
      match: \bNaN\b
    - name: constant.language.infinity.ts
      match: \bInfinity\b

  access-modifier:
    name: storage.modifier.ts
    match: \b(public|protected|private)\b

  static-modifier:
    name: storage.modifier.ts
    match: \b(static)\b

  property-accessor:
    name: storage.type.property.ts
    match: \b(get|set)\b

...
